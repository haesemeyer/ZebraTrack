/*
Copyright 2016 Martin Haesemeyer
   Licensed under the MIT License, see License.txt.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Threading;

using MHApi.Utilities;
using MHApi.Threading;
using MHApi.DrewsClasses;

namespace MHApi.Imaging
{
    /// <summary>
    /// Base class for image trackers
    /// </summary>
    /// <typeparam name="T">Type describing the information generated by the tracker</typeparam>
    public abstract class Tracker<T> : PropertyChangeNotification, IDisposable
    {

        #region Fields

        /// <summary>
        /// The thread on which the tracking is happening
        /// </summary>
        private Worker _trackThread;

        /// <summary>
        /// The ring buffer for thread-safe production and consumption of images
        /// </summary>
        private PrCoImageRingBuffer _frames;

        /// <summary>
        /// Indicates whether the tracker is currently running or not
        /// </summary>
        private bool _isRunning;

        /// <summary>
        /// Buffer for the currentImage which gets passed to the tracking procedure
        /// after recieving the image from the ring buffer
        /// </summary>
        private Image8 _currentImage;

        /// <summary>
        /// Counter of the tracked images
        /// </summary>
        private int _imageIndex;

        #endregion

        #region PropertiesAndEvents
        /*
        /// <summary>
        /// The producer/consumer queue recieving the frames for processing
        /// by the tracker
        /// </summary>
        public ProducerConsumer<Image8> Frames
        {
            get
            {
                return _frames;
            }
            protected set
            {
                _frames = value;
            }
        }
        */
        /// <summary>
        /// Indicates whether the tracker is currently running or not
        /// </summary>
        public bool IsRunning
        {
            get
            {
                return _isRunning;
            }
            protected set
            {
                _isRunning = value;
                RaisePropertyChanged("IsRunning");
            }
        }

        public delegate void TrackResult(T result);

        public event TrackResult NewTrackResult;

        #endregion //Properties and Events

        #region Constructor

        /// <summary>
        /// Initializes a new tracker instance
        /// </summary>
        /// <param name="imageWidth">The width of the images to track</param>
        /// <param name="imageHeight">The height of the images to track</param>
        /// <param name="bufferCount">The number of images to keep in the tracking buffer</param>
        public Tracker(int imageWidth, int imageHeight, int bufferCount)
        {
            _currentImage = new Image8(imageWidth, imageHeight);
            _trackThread = new Worker(TrackThreadRun, false, 1000);
            _frames = new PrCoImageRingBuffer(imageWidth, imageHeight, bufferCount);
            _imageIndex = 0;
        }

        /// <summary>
        /// Initializes a new tracker instance
        /// </summary>
        /// <param name="imageWidth">The width of the images to track</param>
        /// <param name="imageHeight">The height of the images to track</param>
        public Tracker(int imageWidth, int imageHeight)
        {
            _currentImage = new Image8(imageWidth, imageHeight);
            _trackThread = new Worker(TrackThreadRun, false, 500);
            _frames = new PrCoImageRingBuffer(imageWidth, imageHeight, 100);
            _imageIndex = 0;
        }

        #endregion //Constructor

        #region Methods

        /// <summary>
        /// Starts the tracker and the trackthread
        /// </summary>
        public virtual void Start()
        {
            if (IsDisposed)
                throw new ObjectDisposedException("Tracker");
            if (IsRunning)
                return;
            _imageIndex = 0;//reset image index
            //clear ring-buffer
            _frames.ClearBuffer();
            _trackThread.Start();
        }

        /// <summary>
        /// Stops the tracker and the trackthread
        /// </summary>
        public virtual void Stop()
        {
            if (IsDisposed)
                throw new ObjectDisposedException("Tracker");
            if (!IsRunning)
                return;
            _trackThread.Stop();
        }

        /// <summary>
        /// Adds a new image to the tracking queue
        /// </summary>
        /// <param name="newImage">The image to add to the tracking queue</param>
        public void AddImage(Image8 newImage)
        {
            _frames.Produce(newImage);
        }

        /// <summary>
        /// Method for tracking objects in a new frame
        /// </summary>
        /// <param name="frame">The new frame to track</param>
        protected abstract void TrackFrame(Image8 frame, int indexExpected, int indexRetrieved);

        /// <summary>
        /// Invokes the NewTrackResult event
        /// </summary>
        /// <param name="result">The results of the current frame track</param>
        protected virtual void OnTrackResult(T result)
        {
            TrackResult handler = NewTrackResult;
            if (handler != null)
                handler(result);
        }

        /// <summary>
        /// The method running on the trackthread to deque and track incoming frames
        /// </summary>
        /// <param name="stop">EventHandle to signal the thread to stop running</param>
        /// <param name="dispatcher">The dispatcher of the parent thread</param>
        private void TrackThreadRun(AutoResetEvent stop, Dispatcher dispatcher)
        {
            int index;
            while (!stop.WaitOne(0) && !_isDisposed)
            {
                try
                {
                    index = _frames.Consume(_currentImage, stop);
                    TrackFrame(_currentImage, _imageIndex, index);
                }
                catch (OperationCanceledException)
                {
                    //System.Diagnostics.Debug.WriteLine(e.ToString());
                    return;
                }
                _imageIndex++;
            }
        }

        #endregion


        #region IDisposable

        bool _isDisposed;

        public bool IsDisposed
        {
            get
            {
                return _isDisposed;
            }
            protected set
            {
                _isDisposed = true;
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (_trackThread != null)
                    _trackThread.Dispose();
                if (_frames != null)
                    _frames.Dispose();
                if (_currentImage != null)
                    _currentImage.Dispose();
            }
            else
                System.Diagnostics.Debug.WriteLine("Tracker not disposed properly. Dispose tracker before ditching last reference.");
        }

        public void Dispose()
        {
            if (IsDisposed)
                return;
            else
                Dispose(true);
            _isDisposed = true;
        }

        ~Tracker()
        {
            if(!_isDisposed)
                Dispose(false);
        }

        #endregion
    }
}
